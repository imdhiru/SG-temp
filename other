import { AppDispatch } from "../../services/common-service";
import { KeyWithAnyModel, StageFieldModel } from "../model/common-model";
import { store } from "../store/store";
import { ValueUpdateAction } from "../store/value-update-slice";
 
/**
 * The method is used to raise API request if any changes observed in the page fields
 */
export const isFieldUpdate = (
  props: KeyWithAnyModel,
  fieldValue: string,
  fieldName: string
): any => {
  return (_dispatch: AppDispatch) => {
    props.handleFieldDispatch(fieldName, fieldValue);
  };
};
 
export const isFieldValueUpdate = (
  props: KeyWithAnyModel,
  stageSelector: any,
  fieldValue: string
): any => {
  return (dispatch: AppDispatch) => {
    const prevValue =
      stageSelector[0].stageInfo.applicants[fieldIdAppend(props)];
    if (prevValue) {
      if (prevValue !== fieldValue) {
        dispatch(
          ValueUpdateAction.getChangeUpdate({
            id: stageSelector[0].stageId!,
            changes: true,
          })
        );
      }
    } else {
      dispatch(
        ValueUpdateAction.getChangeUpdate({
          id: stageSelector[0].stageId!,
          changes: true,
        })
      );
    }
  };
};
 
/**
 * Method used to notify the global field level errors
 * @param fieldErrorSelector stage response
 * @param props current field object to identify the field error
 * @returns
 */
export const fieldError = (fieldErrorSelector: any, props: KeyWithAnyModel) => {
  if (fieldErrorSelector) {
    if (Object.keys(fieldErrorSelector).length > 0) {
      return fieldErrorSelector.hasOwnProperty(props.data.logical_field_name);
    }
  }
};
 
/**
 * Method used to get the current stage id in the array object to filter
 * @param stageInfo current stage response
 * @param stageId current stage id
 * @returns
 */
export const FindIndex = (stageInfo: any, stageId: string) => {
  return stageInfo.fieldmetadata.data.stages.findIndex(
    (id: StageFieldModel) => id.stageId.toLowerCase() === stageId.toLowerCase()
  );
};
 
/**
 * Method used to get the query param from url
 * @param name url string name
 * @returns
 */
export const getUrl = {
  getParameterByName(name: string) {
    Eif (store) {
      return new URLSearchParams(store.getState().urlParam.urlParams).get(name);
    }
  },
  getProductInfo() {
    return store.getState().urlParam.products;
  },
  getStageInfo() {
    return store.getState().stages.stages;
  },
  getJourneyType() {
    return store.getState().stages.journeyType;
  },
  getOtpShow() {
    return store.getState().stages.otpOpen;
  },
  getOtpTrigger() {
    return store.getState().stages.otpTrigger;
  },
  getOtpResume() {
    return store.getState().stages.otpResume;
  },
  getChangeUpdate() {
    return store.getState().valueUpdate.backNavigation.pegaRequest;
  },
  getChannelRefNo() {
    return store.getState().urlParam.applicationDetails;
  },
  getUrlEndPoint() {
    return store.getState().urlParam.urlEndPoint;
  },
  getLoader() {
    return store.getState().loader;
  },
  getAggregators() {
    return store.getState().urlParam.aggregators;
  },
  getProductDetails() {
    return store.getState().urlParam.products;
  },
  getDocumentStatus() {
    return store.getState().documentUploadList.documentUpdate;
  },
  getUserInputs() {
    return store.getState().stages.userInput.applicants;
  },
  getUpdatedStage() {
    return store.getState().stages;
  },
  getRate() {
    return store.getState().rate;
  },
  getSteps() {
    return store.getState().stepCount;
  },
  getMyInfo() {
    return store.getState().stages.myinfoResponse;
  },
  getTokens() {
    return store.getState().token;
  },
  getAggregatorStatus() {
    if (
      getUrl.getParameterByName("aggregator_code") ||
      getUrl.getParameterByName("aggregator_type") ||
      getUrl.getParameterByName("aggregator_instance")
    ) {
      return true;
    } else {
      return false;
    }
  },
};
 
export const getStoredOTP = () => {
  return store.getState().otp;
};
 
export const getCurrentYear = () => {
  const todate = new Date();
  return todate.getFullYear();
}
 
export const authenticateType = (): string => {
  const auth = getUrl.getParameterByName("auth");
  const isMyInfoVirtual = getUrl.getParameterByName("isMyInfoVirtual");
  const stages = getUrl.getStageInfo();
  let authType = null;
  const oAuth = getUrl.getParameterByName('transfer-token');
 
  Iif (stages && stages[0] && stages[0].stageInfo) {
    authType = stages[0].stageInfo.applicants["auth_mode_a_1"];
  }
  Iif (auth === "myinfo" || isMyInfoVirtual === "true" || authType === "XM") {
    return "myinfo";
  } else Iif (authType === "IX" || oAuth) {
    return "ibnk";
  } else {
    return "manual";
  }
};
 
export const fieldIdAppend = (props: KeyWithAnyModel): string => {
  let fieldId: string = props.data.logical_field_name;
  return fieldId + "_a_1";
};
 
/**
 * Method used to get missing myInfo fields
 * @param formConfigValues formConfig
 * @param myInfoData Myinfo missing fields
 * @returns
 */
 
export const filterDisableFields = (
  formConfigValues: KeyWithAnyModel,
  myInfoData: Array<string>,
  defaultEditable? : Array<string>
) => {
  let filteredFields: Array<string> = [];
  let missingField:boolean;
  formConfigValues.forEach((formConfigFields: KeyWithAnyModel) => {
    let isDefaultEditable =!defaultEditable || (defaultEditable && defaultEditable.indexOf(formConfigFields.logical_field_name) === -1)
      missingField = myInfoData.some(
        (myInfoValue: string) =>
          myInfoValue === formConfigFields.logical_field_name
      );
    if (!missingField && isDefaultEditable) {
      filteredFields.push(formConfigFields.logical_field_name);
    }
  });
  return filteredFields;
};
 
export const isMyinfoField = (
  myInfoResponseSelector: KeyWithAnyModel,
  logical_field_name: string
) => {
  let defaultEditableFields = ['email', 'mobile_number', 'marital_status']
  let isDefaultEditable = !defaultEditableFields || (defaultEditableFields && defaultEditableFields.indexOf(logical_field_name) === -1)
 
  return (
    isDefaultEditable && myInfoResponseSelector.hasOwnProperty(logical_field_name + "_a_1") &&
    myInfoResponseSelector[logical_field_name + "_a_1"]
  );
};
 
/**
 * Method to get device type
 */
export const getDeviceType = () => {
  let device = "Desktop Website";
  let userAgent = window.navigator.userAgent.toLowerCase();
  if (
    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      userAgent
    )
  ) {
    return (device = "Mobile Website");
  }
  return device;
};
 
/**
 * The method used to scroll to first field error
 */
export const smoothScroll = () => {
  setTimeout(() => {
    const errorMsg: any = document.getElementsByClassName('error-msg')[0];
    if (errorMsg) {
      const headerHeight:any = document.getElementsByClassName('app__body')[0];
      document.getElementsByClassName('app__body')[0].scroll({
        top: Math.abs(errorMsg.parentElement.offsetTop - headerHeight.previousElementSibling.offsetHeight),
        left: 0,
        behavior: 'smooth'
      });
    }
  }, 100)
}
 
/**
 * the method used to update the step count sequence based on journey 
 * @param stageSelector 
 * @returns 
 */
export const removeStageIds = (stageSelector:any) => {
  let default_seq = ['ld-1','bd-2','bd-3','doc','ad-1','ad-2','ACD','rp'];
  if(stageSelector &&
    stageSelector.stages &&
    stageSelector.stages.length > 0) {
    if(stageSelector.stages[0].stageInfo.applicants['auth_mode_a_1'] !== 'XN') {
      default_seq.splice(default_seq.indexOf('bd-2'), 1);
    }
    if(stageSelector.stages[0].stageInfo.products[0]['product_category'] !== 'PL') {
      default_seq.splice(default_seq.indexOf('ld-1'), 1);
    }
    if(!(stageSelector.stages[0].stageInfo.applicant_documents && stageSelector.stages[0].stageInfo.applicant_documents.length > 0)) {
      default_seq.splice(default_seq.indexOf('doc'), 1);
    }
    if(stageSelector.stages[0].stageInfo.applicants['credit_limit_consent_a_1'] === 'Y') {
      default_seq.splice(default_seq.indexOf('ad-2'), 1);
    }
    if(stageSelector.stages[0].stageInfo.products[0]['product_category'] !== 'CA' && stageSelector.stages[0].stageInfo.products[0]['product_category'] !== 'SA') {
      default_seq.splice(default_seq.indexOf('ACD'), 1);
      default_seq.splice(default_seq.indexOf('ad-1'), 1);
    }
  }
  return default_seq;
}
/**
 * 
 * @param label keyjson label
 * @returns 
 */
export const keyToken = (label: string) => {
  const getToken = getUrl.getTokens();
  const keyIndex = findKeyTokenIndex(getToken, label);
  const es256Index = getToken.keys[keyIndex].value.findIndex((ref: any) => ref.alg === 'ES256');
  return [getToken.keys[keyIndex].value[es256Index]]
}
 
/**
 * 
 * @param getToken store value
 * @param label key json label
 * @returns 
 */
export const findKeyTokenIndex = (getToken: any, label: string) => {
  return getToken.keys.findIndex((res: any) => res.label === label);
}
 
/**
 * To get channel ref number
 * @returns 
 */
export const getTokenChno = () => {
  const code = getUrl.getParameterByName("isMyInfoVirtualNRIC")
    ? getUrl.getParameterByName("isMyInfoVirtualNRIC")
    : getUrl.getParameterByName("code");
  let token = sessionStorage.getItem("token") ? sessionStorage.getItem("token") : localStorage.getItem('chRefNo');
  if (token === 'undefined') {
    token = null;
  }
  const channelRefNo: any =
    getUrl.getChannelRefNo().channelRefNo !== null
      ? getUrl.getChannelRefNo().channelRefNo
      : JSON.parse(token!);
 
  return {
    code: code,
    channelRefNo: channelRefNo
  }
}





import { isFieldUpdate } from './path-to-your-file';

describe('isFieldUpdate', () => {
  it('should dispatch the correct action on field update', () => {
    const mockDispatch = jest.fn();
    const mockHandleFieldDispatch = jest.fn();
    const props = {
      handleFieldDispatch: mockHandleFieldDispatch,
    };

    const fieldName = 'testField';
    const fieldValue = 'testValue';

    isFieldUpdate(props, fieldValue, fieldName)(mockDispatch);

    expect(mockHandleFieldDispatch).toHaveBeenCalledWith(fieldName, fieldValue);
  });
});




import { isFieldValueUpdate } from './path-to-your-file';
import { ValueUpdateAction } from '../store/value-update-slice';

jest.mock('../store/value-update-slice', () => ({
  ValueUpdateAction: {
    getChangeUpdate: jest.fn(),
  },
}));

describe('isFieldValueUpdate', () => {
  it('should dispatch ValueUpdateAction if fieldValue is updated', () => {
    const mockDispatch = jest.fn();
    const props = { data: { logical_field_name: 'field1' } };
    const stageSelector = [
      { stageInfo: { applicants: { field1_a_1: 'oldValue' } }, stageId: '123' },
    ];
    const fieldValue = 'newValue';

    isFieldValueUpdate(props, stageSelector, fieldValue)(mockDispatch);

    expect(ValueUpdateAction.getChangeUpdate).toHaveBeenCalledWith({
      id: '123',
      changes: true,
    });
    expect(mockDispatch).toHaveBeenCalled();
  });
});

import { fieldError } from './path-to-your-file';

describe('fieldError', () => {
  it('should return true if field error exists', () => {
    const fieldErrorSelector = { logical_field_name: true };
    const props = { data: { logical_field_name: 'logical_field_name' } };

    const result = fieldError(fieldErrorSelector, props);

    expect(result).toBe(true);
  });

  it('should return undefined if no field error exists', () => {
    const fieldErrorSelector = {};
    const props = { data: { logical_field_name: 'logical_field_name' } };

    const result = fieldError(fieldErrorSelector, props);

    expect(result).toBeUndefined();
  });
});

import { getDeviceType } from './path-to-your-file';

describe('getDeviceType', () => {
  it('should return "Mobile Website" for mobile user agents', () => {
    Object.defineProperty(window.navigator, 'userAgent', {
      value: 'iPhone',
      configurable: true,
    });

    expect(getDeviceType()).toBe('Mobile Website');
  });

  it('should return "Desktop Website" for desktop user agents', () => {
    Object.defineProperty(window.navigator, 'userAgent', {
      value: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
      configurable: true,
    });

    expect(getDeviceType()).toBe('Desktop Website');
  });
});


import { smoothScroll } from './path-to-your-file';

describe('smoothScroll', () => {
  beforeEach(() => {
    document.body.innerHTML = `
      <div class="app__body">
        <div class="header"></div>
        <div class="error-msg"></div>
      </div>
    `;
  });

  it('should scroll to the first error message', () => {
    const scrollMock = jest.fn();
    Element.prototype.scroll = scrollMock;

    smoothScroll();

    setTimeout(() => {
      expect(scrollMock).toHaveBeenCalled();
    }, 100);
  });
});

import { filterDisableFields } from './path-to-your-file';

describe('filterDisableFields', () => {
  it('should filter out missing fields', () => {
    const formConfigValues = [
      { logical_field_name: 'field1' },
      { logical_field_name: 'field2' },
    ];
    const myInfoData = ['field2'];
    const defaultEditable = ['field3'];

    const result = filterDisableFields(formConfigValues, myInfoData, defaultEditable);

    expect(result).toEqual(['field1']);
  });
});



import { getUrl } from './path-to-your-file';
import { store } from '../store/store';

jest.mock('../store/store', () => ({
  store: {
    getState: jest.fn(),
  },
}));

describe('getUrl', () => {
  it('should return the correct query parameter value', () => {
    store.getState.mockReturnValue({
      urlParam: {
        urlParams: 'param1=value1&param2=value2',
      },
    });

    const result = getUrl.getParameterByName('param1');

    expect(result).toBe('value1');
  });

  it('should return products from state', () => {
    store.getState.mockReturnValue({
      urlParam: {
        products: [{ name: 'Product 1' }],
      },
    });

    const result = getUrl.getProductInfo();

    expect(result).toEqual([{ name: 'Product 1' }]);
  });
});





import { FindIndex, getStoredOTP, getCurrentYear, authenticateType, fieldIdAppend, filterDisableFields, isMyinfoField, getDeviceType, removeStageIds, keyToken, findKeyTokenIndex, getTokenChno } from '../your-file-name'; // Update with correct path
import configureStore from 'redux-mock-store';

const mockStore = configureStore();
const store = mockStore({
  otp: '123456',
  urlParam: {
    urlParams: '?auth=myinfo&isMyInfoVirtual=true',
    channelRefNo: { channelRefNo: 'REF123' },
  },
  stages: {
    stages: [{ stageInfo: { applicants: { auth_mode_a_1: 'XM' } } }],
  },
});

describe('Utility Function Tests', () => {
  beforeEach(() => {
    store.clearActions();
  });

  test('FindIndex should return correct index', () => {
    const stageInfo = {
      fieldmetadata: {
        data: {
          stages: [{ stageId: 'stage-1' }, { stageId: 'stage-2' }],
        },
      },
    };
    const result = FindIndex(stageInfo, 'STAGE-1');
    expect(result).toBe(0);
  });

  test('getStoredOTP should return OTP from store', () => {
    expect(getStoredOTP()).toBe('123456');
  });

  test('getCurrentYear should return the current year', () => {
    const currentYear = new Date().getFullYear();
    expect(getCurrentYear()).toBe(currentYear);
  });

  test('authenticateType should return "myinfo" for specific parameters', () => {
    jest.spyOn(URLSearchParams.prototype, 'get').mockImplementation((param) => {
      if (param === 'auth') return 'myinfo';
      if (param === 'isMyInfoVirtual') return 'true';
      return null;
    });

    expect(authenticateType()).toBe('myinfo');
  });

  test('fieldIdAppend should append "_a_1" to field name', () => {
    const props = { data: { logical_field_name: 'field1' } };
    expect(fieldIdAppend(props)).toBe('field1_a_1');
  });

  test('filterDisableFields should return non-missing fields', () => {
    const formConfigValues = [{ logical_field_name: 'email' }, { logical_field_name: 'name' }];
    const myInfoData = ['email'];
    const result = filterDisableFields(formConfigValues, myInfoData);
    expect(result).toEqual(['name']);
  });

  test('isMyinfoField should return true for valid field', () => {
    const myInfoResponseSelector = { email_a_1: 'test@test.com' };
    expect(isMyinfoField(myInfoResponseSelector, 'email')).toBe(true);
  });

  test('getDeviceType should identify mobile devices', () => {
    const mockUserAgent = jest.spyOn(window.navigator, 'userAgent', 'get');
    mockUserAgent.mockReturnValue('iPhone');
    expect(getDeviceType()).toBe('Mobile Website');

    mockUserAgent.mockReturnValue('Windows');
    expect(getDeviceType()).toBe('Desktop Website');
  });

  test('removeStageIds should modify sequence correctly', () => {
    const stageSelector = {
      stages: [
        {
          stageInfo: {
            applicants: { auth_mode_a_1: 'XN', credit_limit_consent_a_1: 'N' },
            products: [{ product_category: 'PL' }],
            applicant_documents: [],
          },
        },
      ],
    };
    const result = removeStageIds(stageSelector);
    expect(result).toEqual(['ld-1', 'bd-2', 'bd-3', 'rp']);
  });

  test('keyToken should return correct token', () => {
    const mockTokens = {
      keys: [
        {
          label: 'testLabel',
          value: [{ alg: 'RS256' }, { alg: 'ES256' }],
        },
      ],
    };
    jest.spyOn(getUrl, 'getTokens').mockReturnValue(mockTokens);
    const result = keyToken('testLabel');
    expect(result).toEqual([{ alg: 'ES256' }]);
  });

  test('findKeyTokenIndex should find correct index', () => {
    const tokens = { keys: [{ label: 'label1' }, { label: 'label2' }] };
    expect(findKeyTokenIndex(tokens, 'label2')).toBe(1);
  });

  test('getTokenChno should return correct channel reference number', () => {
    jest.spyOn(URLSearchParams.prototype, 'get').mockImplementation((param) => {
      if (param === 'code') return 'CODE123';
      return null;
    });
    const result = getTokenChno();
    expect(result).toEqual({ code: 'CODE123', channelRefNo: 'REF123' });
  });
});








